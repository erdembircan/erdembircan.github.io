<!DOCTYPE html><!--aVlbi0N_a07Gu_eumQmsc--><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/4cf2300e9c8272f7-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="https://github.com/erdembircan.png"/><link rel="stylesheet" href="/_next/static/css/bf148c4dfe225d7c.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-01e7dd0b6d0e9da1.js"/><script src="/_next/static/chunks/4bd1b696-c023c6e3521b1417.js" async=""></script><script src="/_next/static/chunks/255-5d038f43a4c9d328.js" async=""></script><script src="/_next/static/chunks/main-app-e23a643470bd50df.js" async=""></script><script src="/_next/static/chunks/619-ba102abea3e3d0e4.js" async=""></script><script src="/_next/static/chunks/app/layout-9fa69e50d7a54f20.js" async=""></script><meta name="next-size-adjust" content=""/><title>Erdem Bircan | WordPress Architect &amp; Developer</title><meta name="description" content="WordPress software architect specializing in plugin development, Gutenberg blocks, and scalable architectures. 10 years building production-grade products."/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_188709 __variable_9a8899 antialiased"><div hidden=""><!--$--><!--/$--></div><header class="sticky top-0 z-50 bg-white shadow-sm"><div class="max-w-6xl mx-auto px-8"><div class="flex justify-between items-center py-6"><div class="flex items-center gap-4"><img src="https://github.com/erdembircan.png" alt="Erdem Bircan" class="w-12 h-12 rounded-full border-4 border-accent"/><div><h1 class="text-lg font-bold tracking-tight"><a class="hover:text-accent transition-colors" href="/">Erdem Bircan</a></h1><p class="text-sm text-muted">WordPress Architect</p></div></div><nav><ul class="flex gap-8"><li><a class="text-muted hover:text-foreground font-medium transition-colors" href="/">About</a></li><li><a class="text-foreground font-medium transition-colors" href="/blog">Blog</a></li></ul></nav></div></div></header><div class="min-h-screen p-8"><article class="max-w-4xl mx-auto"><header class="mb-8"><h1 class="text-4xl font-bold mb-4">WordPress CPTs and the REST API Read Permission Gap</h1><p class="text-sm text-foreground/70 mb-4">2/18/2026</p><div class="flex gap-2 flex-wrap"><span class="text-xs border border-foreground/30 px-2 py-1">wordpress</span><span class="text-xs border border-foreground/30 px-2 py-1">rest-api</span><span class="text-xs border border-foreground/30 px-2 py-1">playwright</span><span class="text-xs border border-foreground/30 px-2 py-1">testing</span></div></header><div class="prose prose-invert max-w-none"><p>You register a custom post type with <code>&#x27;public&#x27; =&gt; false</code> and map every capability to a custom one. You expect unauthenticated users to be locked out entirely. Then you write a Playwright test, fire a <code>GET /wp-json/wp/v2/your_cpt</code>, and it returns <code>200 OK</code> with an empty array.</p>
<p>What happened?</p>
<h2>The Problem</h2>
<p>WordPress treats REST API read permissions differently from write permissions. When you register a CPT with custom capabilities:</p>
<pre><code class="language-php">register_post_type(&#x27;secret_note&#x27;, [
    &#x27;public&#x27;       =&gt; false,
    &#x27;show_in_rest&#x27; =&gt; true,
    &#x27;capabilities&#x27; =&gt; [
        &#x27;edit_posts&#x27;   =&gt; &#x27;manage_secret_notes&#x27;,
        &#x27;create_posts&#x27; =&gt; &#x27;manage_secret_notes&#x27;,
        &#x27;delete_posts&#x27; =&gt; &#x27;manage_secret_notes&#x27;,
        // ... every cap mapped to manage_secret_notes
    ],
]);
</code></pre>
<p>Write endpoints (<code>POST</code>, <code>DELETE</code>) correctly check <code>create_posts</code> / <code>delete_posts</code> and return <code>401</code> for anonymous users. But <code>GET</code> requests go through <code>WP_REST_Posts_Controller::get_items_permissions_check()</code>, which allows read access as long as the query parameters are &quot;safe.&quot; If you&#x27;re only requesting published posts with no special filters, WordPress says &quot;sure, go ahead&quot; -- regardless of your capability mapping.</p>
<p>The reasoning is that <code>public =&gt; false</code> controls visibility in the admin UI and query defaults, not REST API read access. And <code>show_in_rest =&gt; true</code> explicitly opts the post type into the API. WordPress assumes that if you opted in, you want public reads.</p>
<p>That&#x27;s a reasonable default for most post types. Not for ours.</p>
<h2>The Fix: A Custom REST Controller</h2>
<p>The solution is a custom controller that enforces your capability on read endpoints:</p>
<pre><code class="language-php">class PrivatePostController extends WP_REST_Posts_Controller {

    public function get_items_permissions_check($request) {
        $post_type = get_post_type_object($this-&gt;post_type);

        if (!current_user_can($post_type-&gt;cap-&gt;edit_posts)) {
            return new WP_Error(
                &#x27;rest_forbidden&#x27;,
                __(&#x27;Sorry, you are not allowed to access this resource.&#x27;),
                [&#x27;status&#x27; =&gt; rest_authorization_required_code()]
            );
        }

        return parent::get_items_permissions_check($request);
    }

    public function get_item_permissions_check($request) {
        $post_type = get_post_type_object($this-&gt;post_type);

        if (!current_user_can($post_type-&gt;cap-&gt;edit_posts)) {
            return new WP_Error(
                &#x27;rest_forbidden&#x27;,
                __(&#x27;Sorry, you are not allowed to access this resource.&#x27;),
                [&#x27;status&#x27; =&gt; rest_authorization_required_code()]
            );
        }

        return parent::get_item_permissions_check($request);
    }
}
</code></pre>
<p>Then wire it up during registration:</p>
<pre><code class="language-php">register_post_type(&#x27;secret_note&#x27;, [
    &#x27;rest_controller_class&#x27; =&gt; PrivatePostController::class,
    // ... rest of args
]);
</code></pre>
<p>Now both <code>get_items</code> (list) and <code>get_item</code> (single) check the mapped capability before proceeding. Anonymous users get <code>401</code>. Authorized users fall through to the parent&#x27;s check, which handles edge cases like post status and password protection.</p>
<h2>Testing It with Playwright</h2>
<p>This is where things get interesting. Our authenticated tests use <code>@wordpress/e2e-test-utils-playwright</code>, which provides a <code>requestUtils</code> fixture. This fixture handles authentication automatically -- it logs in as <code>admin</code> and attaches cookies/nonce to every request:</p>
<pre><code class="language-typescript">import { test, expect } from &#x27;@wordpress/e2e-test-utils-playwright&#x27;;

test(&#x27;REST API endpoint exists and responds&#x27;, async ({ requestUtils }) =&gt; {
  const response = await requestUtils.rest({
    path: &#x27;/wp/v2/secret_note&#x27;,
    method: &#x27;GET&#x27;,
  });
  expect(Array.isArray(response)).toBe(true);
});
</code></pre>
<p>But <code>requestUtils</code> always sends authenticated requests. You can&#x27;t use it to test what an anonymous visitor sees.</p>
<h3>Two Playground Instances</h3>
<p>We run WordPress Playground as our test backend. The key insight: we spin up <strong>two separate instances</strong> with different blueprints.</p>
<p>The authenticated instance includes a <code>login</code> step in its blueprint:</p>
<pre><code class="language-typescript">const loginStep = [{ step: &#x27;login&#x27;, username: &#x27;admin&#x27; }];

export const setupBlueprint = {
  preferredVersions: { php: &#x27;8.2&#x27;, wp: &#x27;latest&#x27; },
  steps: [...loginStep, ...debugStep, ...pluginStep],
};
</code></pre>
<p>The Playground <code>login</code> step creates a session cookie that <code>@wordpress/e2e-test-utils-playwright</code> picks up. Every <code>requestUtils.rest()</code> call sends this cookie, so WordPress sees an authenticated admin user.</p>
<p>The unauthenticated instance skips the login step entirely:</p>
<pre><code class="language-typescript">export const setupBlueprintNoLogin = {
  preferredVersions: { php: &#x27;8.2&#x27;, wp: &#x27;latest&#x27; },
  steps: [...debugStep, ...pluginStep],
};
</code></pre>
<p>No login, no cookie, no session. This instance runs on a different port.</p>
<h3>Separate Test Projects</h3>
<p>Playwright&#x27;s config maps each instance to a test project:</p>
<pre><code class="language-typescript">export default defineConfig({
  webServer: [
    { command: &#x27;pnpm playground:test&#x27; /* port 9401 */ },
    { command: &#x27;pnpm playground:test-noauth&#x27; /* port 9402 */ },
  ],
  projects: [
    {
      name: &#x27;authenticated&#x27;,
      testDir: &#x27;./tests/e2e&#x27;,
      use: { baseURL: &#x27;http://127.0.0.1:9401&#x27; },
    },
    {
      name: &#x27;unauthenticated&#x27;,
      testDir: &#x27;./tests/e2e-unauth&#x27;,
      use: { baseURL: &#x27;http://127.0.0.1:9402&#x27; },
    },
  ],
});
</code></pre>
<h3>Raw Playwright for Unauthenticated Tests</h3>
<p>Since <code>requestUtils</code> always authenticates, the unauthenticated tests use Playwright&#x27;s raw <code>request</code> API instead:</p>
<pre><code class="language-typescript">import { test, expect, request } from &#x27;@playwright/test&#x27;;

test(&#x27;listing posts should fail&#x27;, async ({ baseURL }) =&gt; {
  const api = await request.newContext({ baseURL: baseURL! });
  const response = await api.get(&#x27;/wp-json/wp/v2/secret_note&#x27;);
  expect(response.status()).toBe(401);
  await api.dispose();
});
</code></pre>
<p>Note the import: <code>@playwright/test</code>, not <code>@wordpress/e2e-test-utils-playwright</code>. No fixtures, no auth, just a plain HTTP request against the no-login instance.</p>
<h2>The Takeaway</h2>
<p>WordPress REST API permissions have a split personality: writes check capabilities, reads often don&#x27;t. If your CPT is private, <code>&#x27;public&#x27; =&gt; false</code> alone won&#x27;t protect the REST endpoints. You need a custom controller to close the gap -- and you need separate test environments to verify both sides of that gap.</p></div></article></div><!--$--><!--/$--><footer class="py-6"><div class="max-w-6xl mx-auto px-8"><section class="p-12 bg-gradient-to-br from-accent to-accent-secondary rounded-[20px] text-white text-center"><h2 class="text-4xl font-bold mb-4">Let&#x27;s Build Something Amazing</h2><p class="text-lg mb-8 opacity-95 max-w-2xl mx-auto">Whether you need WordPress expertise, want to collaborate on a project, or just want to chat about plugin architecture and modern development practices, I&#x27;d love to hear from you!</p><div class="flex gap-4 justify-center flex-wrap"><a href="mailto:erdem.erdembircan@gmail.com" class="px-8 py-3.5 bg-white text-accent font-semibold rounded-lg hover:-translate-y-0.5 hover:shadow-xl transition-all">Get in Touch</a><a href="https://github.com/erdembircan" class="px-8 py-3.5 bg-transparent border-2 border-white text-white font-semibold rounded-lg hover:bg-white hover:text-accent transition-all">View My GitHub</a></div></section></div></footer><script src="/_next/static/chunks/webpack-01e7dd0b6d0e9da1.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[4205,[\"619\",\"static/chunks/619-ba102abea3e3d0e4.js\",\"177\",\"static/chunks/app/layout-9fa69e50d7a54f20.js\"],\"default\"]\n3:I[9766,[],\"\"]\n4:I[8924,[],\"\"]\n6:I[4431,[],\"OutletBoundary\"]\n8:I[5278,[],\"AsyncMetadataOutlet\"]\na:I[4431,[],\"ViewportBoundary\"]\nc:I[4431,[],\"MetadataBoundary\"]\nd:\"$Sreact.suspense\"\nf:I[7150,[],\"\"]\n:HL[\"/_next/static/media/4cf2300e9c8272f7-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/bf148c4dfe225d7c.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"aVlbi0N-a07Gu-eumQmsc\",\"p\":\"\",\"c\":[\"\",\"blog\",\"testing-unauthenticated-cpt-requests\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"testing-unauthenticated-cpt-requests\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/bf148c4dfe225d7c.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_188709 __variable_9a8899 antialiased\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"className\":\"py-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-6xl mx-auto px-8\",\"children\":[\"$\",\"section\",null,{\"className\":\"p-12 bg-gradient-to-br from-accent to-accent-secondary rounded-[20px] text-white text-center\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"text-4xl font-bold mb-4\",\"children\":\"Let's Build Something Amazing\"}],[\"$\",\"p\",null,{\"className\":\"text-lg mb-8 opacity-95 max-w-2xl mx-auto\",\"children\":\"Whether you need WordPress expertise, want to collaborate on a project, or just want to chat about plugin architecture and modern development practices, I'd love to hear from you!\"}],[\"$\",\"div\",null,{\"className\":\"flex gap-4 justify-center flex-wrap\",\"children\":[[\"$\",\"a\",\"Get in Touch\",{\"href\":\"mailto:erdem.erdembircan@gmail.com\",\"className\":\"px-8 py-3.5 bg-white text-accent font-semibold rounded-lg hover:-translate-y-0.5 hover:shadow-xl transition-all\",\"children\":\"Get in Touch\"}],[\"$\",\"a\",\"View My GitHub\",{\"href\":\"https://github.com/erdembircan\",\"className\":\"px-8 py-3.5 bg-transparent border-2 border-white text-white font-semibold rounded-lg hover:bg-white hover:text-accent transition-all\",\"children\":\"View My GitHub\"}]]}]]}]}]}]]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"testing-unauthenticated-cpt-requests\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",null,[\"$\",\"$L6\",null,{\"children\":[\"$L7\",[\"$\",\"$L8\",null,{\"promise\":\"$@9\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[[\"$\",\"$La\",null,{\"children\":\"$Lb\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]],[\"$\",\"$Lc\",null,{\"children\":[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$d\",null,{\"fallback\":null,\"children\":\"$Le\"}]}]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$f\",[]],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"min-h-screen p-8\",\"children\":[\"$\",\"article\",null,{\"className\":\"max-w-4xl mx-auto\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold mb-4\",\"children\":\"WordPress CPTs and the REST API Read Permission Gap\"}],[\"$\",\"p\",null,{\"className\":\"text-sm text-foreground/70 mb-4\",\"children\":\"2/18/2026\"}],[\"$\",\"div\",null,{\"className\":\"flex gap-2 flex-wrap\",\"children\":[[\"$\",\"span\",\"0\",{\"className\":\"text-xs border border-foreground/30 px-2 py-1\",\"children\":\"wordpress\"}],[\"$\",\"span\",\"1\",{\"className\":\"text-xs border border-foreground/30 px-2 py-1\",\"children\":\"rest-api\"}],[\"$\",\"span\",\"2\",{\"className\":\"text-xs border border-foreground/30 px-2 py-1\",\"children\":\"playwright\"}],[\"$\",\"span\",\"3\",{\"className\":\"text-xs border border-foreground/30 px-2 py-1\",\"children\":\"testing\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"prose prose-invert max-w-none\",\"children\":\"$L10\"}]]}]}]\n"])</script><script>self.__next_f.push([1,"11:T40b,"])</script><script>self.__next_f.push([1,"class PrivatePostController extends WP_REST_Posts_Controller {\n\n    public function get_items_permissions_check($request) {\n        $post_type = get_post_type_object($this-\u003epost_type);\n\n        if (!current_user_can($post_type-\u003ecap-\u003eedit_posts)) {\n            return new WP_Error(\n                'rest_forbidden',\n                __('Sorry, you are not allowed to access this resource.'),\n                ['status' =\u003e rest_authorization_required_code()]\n            );\n        }\n\n        return parent::get_items_permissions_check($request);\n    }\n\n    public function get_item_permissions_check($request) {\n        $post_type = get_post_type_object($this-\u003epost_type);\n\n        if (!current_user_can($post_type-\u003ecap-\u003eedit_posts)) {\n            return new WP_Error(\n                'rest_forbidden',\n                __('Sorry, you are not allowed to access this resource.'),\n                ['status' =\u003e rest_authorization_required_code()]\n            );\n        }\n\n        return parent::get_item_permissions_check($request);\n    }\n}\n"])</script><script>self.__next_f.push([1,"10:[[\"$\",\"p\",null,{\"children\":[\"You register a custom post type with \",[\"$\",\"code\",null,{\"children\":\"'public' =\u003e false\"}],\" and map every capability to a custom one. You expect unauthenticated users to be locked out entirely. Then you write a Playwright test, fire a \",[\"$\",\"code\",null,{\"children\":\"GET /wp-json/wp/v2/your_cpt\"}],\", and it returns \",[\"$\",\"code\",null,{\"children\":\"200 OK\"}],\" with an empty array.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"What happened?\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"The Problem\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"WordPress treats REST API read permissions differently from write permissions. When you register a CPT with custom capabilities:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-php\",\"children\":\"register_post_type('secret_note', [\\n    'public'       =\u003e false,\\n    'show_in_rest' =\u003e true,\\n    'capabilities' =\u003e [\\n        'edit_posts'   =\u003e 'manage_secret_notes',\\n        'create_posts' =\u003e 'manage_secret_notes',\\n        'delete_posts' =\u003e 'manage_secret_notes',\\n        // ... every cap mapped to manage_secret_notes\\n    ],\\n]);\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Write endpoints (\",[\"$\",\"code\",null,{\"children\":\"POST\"}],\", \",[\"$\",\"code\",null,{\"children\":\"DELETE\"}],\") correctly check \",[\"$\",\"code\",null,{\"children\":\"create_posts\"}],\" / \",[\"$\",\"code\",null,{\"children\":\"delete_posts\"}],\" and return \",[\"$\",\"code\",null,{\"children\":\"401\"}],\" for anonymous users. But \",[\"$\",\"code\",null,{\"children\":\"GET\"}],\" requests go through \",[\"$\",\"code\",null,{\"children\":\"WP_REST_Posts_Controller::get_items_permissions_check()\"}],\", which allows read access as long as the query parameters are \\\"safe.\\\" If you're only requesting published posts with no special filters, WordPress says \\\"sure, go ahead\\\" -- regardless of your capability mapping.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The reasoning is that \",[\"$\",\"code\",null,{\"children\":\"public =\u003e false\"}],\" controls visibility in the admin UI and query defaults, not REST API read access. And \",[\"$\",\"code\",null,{\"children\":\"show_in_rest =\u003e true\"}],\" explicitly opts the post type into the API. WordPress assumes that if you opted in, you want public reads.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"That's a reasonable default for most post types. Not for ours.\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"The Fix: A Custom REST Controller\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The solution is a custom controller that enforces your capability on read endpoints:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-php\",\"children\":\"$11\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Then wire it up during registration:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-php\",\"children\":\"register_post_type('secret_note', [\\n    'rest_controller_class' =\u003e PrivatePostController::class,\\n    // ... rest of args\\n]);\\n\"}]}],\"\\n\",\"$L12\",\"\\n\",\"$L13\",\"\\n\",\"$L14\",\"\\n\",\"$L15\",\"\\n\",\"$L16\",\"\\n\",\"$L17\",\"\\n\",\"$L18\",\"\\n\",\"$L19\",\"\\n\",\"$L1a\",\"\\n\",\"$L1b\",\"\\n\",\"$L1c\",\"\\n\",\"$L1d\",\"\\n\",\"$L1e\",\"\\n\",\"$L1f\",\"\\n\",\"$L20\",\"\\n\",\"$L21\",\"\\n\",\"$L22\",\"\\n\",\"$L23\",\"\\n\",\"$L24\",\"\\n\",\"$L25\",\"\\n\",\"$L26\",\"\\n\",\"$L27\"]\n"])</script><script>self.__next_f.push([1,"12:[\"$\",\"p\",null,{\"children\":[\"Now both \",[\"$\",\"code\",null,{\"children\":\"get_items\"}],\" (list) and \",[\"$\",\"code\",null,{\"children\":\"get_item\"}],\" (single) check the mapped capability before proceeding. Anonymous users get \",[\"$\",\"code\",null,{\"children\":\"401\"}],\". Authorized users fall through to the parent's check, which handles edge cases like post status and password protection.\"]}]\n13:[\"$\",\"h2\",null,{\"children\":\"Testing It with Playwright\"}]\n14:[\"$\",\"p\",null,{\"children\":[\"This is where things get interesting. Our authenticated tests use \",[\"$\",\"code\",null,{\"children\":\"@wordpress/e2e-test-utils-playwright\"}],\", which provides a \",[\"$\",\"code\",null,{\"children\":\"requestUtils\"}],\" fixture. This fixture handles authentication automatically -- it logs in as \",[\"$\",\"code\",null,{\"children\":\"admin\"}],\" and attaches cookies/nonce to every request:\"]}]\n15:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-typescript\",\"children\":\"import { test, expect } from '@wordpress/e2e-test-utils-playwright';\\n\\ntest('REST API endpoint exists and responds', async ({ requestUtils }) =\u003e {\\n  const response = await requestUtils.rest({\\n    path: '/wp/v2/secret_note',\\n    method: 'GET',\\n  });\\n  expect(Array.isArray(response)).toBe(true);\\n});\\n\"}]}]\n16:[\"$\",\"p\",null,{\"children\":[\"But \",[\"$\",\"code\",null,{\"children\":\"requestUtils\"}],\" always sends authenticated requests. You can't use it to test what an anonymous visitor sees.\"]}]\n17:[\"$\",\"h3\",null,{\"children\":\"Two Playground Instances\"}]\n18:[\"$\",\"p\",null,{\"children\":[\"We run WordPress Playground as our test backend. The key insight: we spin up \",[\"$\",\"strong\",null,{\"children\":\"two separate instances\"}],\" with different blueprints.\"]}]\n19:[\"$\",\"p\",null,{\"children\":[\"The authenticated instance includes a \",[\"$\",\"code\",null,{\"children\":\"login\"}],\" step in its blueprint:\"]}]\n1a:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-typescript\",\"children\":\"const loginStep = [{ step: 'login', username: 'admin' }];\\n\\nexport const setupBlueprint = {\\n  preferredVers"])</script><script>self.__next_f.push([1,"ions: { php: '8.2', wp: 'latest' },\\n  steps: [...loginStep, ...debugStep, ...pluginStep],\\n};\\n\"}]}]\n1b:[\"$\",\"p\",null,{\"children\":[\"The Playground \",[\"$\",\"code\",null,{\"children\":\"login\"}],\" step creates a session cookie that \",[\"$\",\"code\",null,{\"children\":\"@wordpress/e2e-test-utils-playwright\"}],\" picks up. Every \",[\"$\",\"code\",null,{\"children\":\"requestUtils.rest()\"}],\" call sends this cookie, so WordPress sees an authenticated admin user.\"]}]\n1c:[\"$\",\"p\",null,{\"children\":\"The unauthenticated instance skips the login step entirely:\"}]\n1d:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-typescript\",\"children\":\"export const setupBlueprintNoLogin = {\\n  preferredVersions: { php: '8.2', wp: 'latest' },\\n  steps: [...debugStep, ...pluginStep],\\n};\\n\"}]}]\n1e:[\"$\",\"p\",null,{\"children\":\"No login, no cookie, no session. This instance runs on a different port.\"}]\n1f:[\"$\",\"h3\",null,{\"children\":\"Separate Test Projects\"}]\n20:[\"$\",\"p\",null,{\"children\":\"Playwright's config maps each instance to a test project:\"}]\n21:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-typescript\",\"children\":\"export default defineConfig({\\n  webServer: [\\n    { command: 'pnpm playground:test' /* port 9401 */ },\\n    { command: 'pnpm playground:test-noauth' /* port 9402 */ },\\n  ],\\n  projects: [\\n    {\\n      name: 'authenticated',\\n      testDir: './tests/e2e',\\n      use: { baseURL: 'http://127.0.0.1:9401' },\\n    },\\n    {\\n      name: 'unauthenticated',\\n      testDir: './tests/e2e-unauth',\\n      use: { baseURL: 'http://127.0.0.1:9402' },\\n    },\\n  ],\\n});\\n\"}]}]\n22:[\"$\",\"h3\",null,{\"children\":\"Raw Playwright for Unauthenticated Tests\"}]\n23:[\"$\",\"p\",null,{\"children\":[\"Since \",[\"$\",\"code\",null,{\"children\":\"requestUtils\"}],\" always authenticates, the unauthenticated tests use Playwright's raw \",[\"$\",\"code\",null,{\"children\":\"request\"}],\" API instead:\"]}]\n24:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-typescript\",\"children\":\"import { test, expect, request } from '@playwright/test';\\n\\nte"])</script><script>self.__next_f.push([1,"st('listing posts should fail', async ({ baseURL }) =\u003e {\\n  const api = await request.newContext({ baseURL: baseURL! });\\n  const response = await api.get('/wp-json/wp/v2/secret_note');\\n  expect(response.status()).toBe(401);\\n  await api.dispose();\\n});\\n\"}]}]\n25:[\"$\",\"p\",null,{\"children\":[\"Note the import: \",[\"$\",\"code\",null,{\"children\":\"@playwright/test\"}],\", not \",[\"$\",\"code\",null,{\"children\":\"@wordpress/e2e-test-utils-playwright\"}],\". No fixtures, no auth, just a plain HTTP request against the no-login instance.\"]}]\n26:[\"$\",\"h2\",null,{\"children\":\"The Takeaway\"}]\n27:[\"$\",\"p\",null,{\"children\":[\"WordPress REST API permissions have a split personality: writes check capabilities, reads often don't. If your CPT is private, \",[\"$\",\"code\",null,{\"children\":\"'public' =\u003e false\"}],\" alone won't protect the REST endpoints. You need a custom controller to close the gap -- and you need separate test environments to verify both sides of that gap.\"]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n7:null\n"])</script><script>self.__next_f.push([1,"28:I[622,[],\"IconMark\"]\n9:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Erdem Bircan | WordPress Architect \u0026 Developer\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"WordPress software architect specializing in plugin development, Gutenberg blocks, and scalable architectures. 10 years building production-grade products.\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"$L28\",\"3\",{}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script>self.__next_f.push([1,"e:\"$9:metadata\"\n"])</script></body></html>